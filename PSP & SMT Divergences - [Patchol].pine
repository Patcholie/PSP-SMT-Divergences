// Function to extract the base symbol from a full symbol string
getShortSymbolName(fullSymbol) =>
    // Find the position of the colon if it exists
    colonPos = str.pos(fullSymbol, ":")
    
    // If colon exists, extract the part after the colon, otherwise use the full symbol
    result = colonPos > 0 ? str.substring(fullSymbol, colonPos + 1) : fullSymbol
    
    // Return the shortened symbol name
    result// SMT Divergences & PSP Indicator
// Copyright © 2025 Aviv Shaked. All Rights Reserved.
// Modified by Aviv Shaked on 3/03/2025 - Added zones to PSP & new issues.
// Licensed exclusively to Aviv Shaked for personal use only.
// REDISTRIBUTION IN ANY FORM IS STRICTLY PROHIBITED.
// This software may only be obtained directly from Aviv Shaked.

//@version=6
// @description Enhanced Precision Candles & SMT Divergence with improved reliability and customization
// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║             PRECISION CANDLES & SMT DIVERGENCE INDICATOR                     ║
// ║                                                                              ║
// ║  PURPOSE: Detects intermarket divergences and precision swing points for     ║
// ║           improved trade entry timing and market analysis.                   ║
// ║                                                                              ║
// ║  RELIABILITY INFORMATION:                                                    ║
// ║  • PSP Detection: Medium reliability - depends on symbol correlation         ║
// ║  • Divergence Detection: Medium reliability - use confirmation               ║
// ║  • Multiple Fractal Periods: Use primary for signals, others for context     ║
// ║  • Correlation Analysis: Valid only when above minimum threshold             ║
// ║                                                                              ║
// ║  IMPORTANT LIMITATIONS:                                                      ║
// ║  • Heavily dependent on correlation between symbols                          ║
// ║  • PSP detection uses swing point reverse direction logic without confirms   ║
// ║  • Fixed fractal periods may not adapt well to different market conditions   ║
// ║  • Higher false signal rate in choppy or sideways markets                    ║
// ║  • No adjustments for varying volatility environments                        ║
// ║                                                                              ║
// ║  BEST PRACTICES:                                                             ║
// ║  • Choose comparison symbols with strong and stable correlations             ║
// ║  • Use the strength filtering options to reduce false signals                ║
// ║  • Apply on higher timeframes to reduce noise                                ║
// ║  • Combine with additional confirmation signals before trading               ║
// ║  • Consider PSP signals as areas of interest, not exact entry/exit points    ║
// ║  • Monitor correlation value - signals unreliable when correlation is weak   ║
// ║                                                                              ║
// ║  OPTIMAL USAGE:                                                              ║
// ║  • Most effective with highly correlated pairs (ES1/NQ1, sector ETFs)        ║
// ║  • Works best in trending markets with clear directional moves               ║
// ║  • Lower settings for fractal periods in higher timeframes                   ║
// ║  • Higher strength filter values in volatile markets                         ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝

indicator("Imbalances: Precision Candles & SMT Divergence - [Patchol]", shorttitle = "PSP & SMT [Patchol]", overlay=true, max_bars_back = 5000, max_lines_count = 500)

// ==========================================
// ===== ORGANIZED INPUT PARAMETERS ========
// ==========================================

// General Settings Group
g_general = "General Settings"
i_show_correlation = input.bool(true, "Show Symbol Correlation", tooltip="Display correlation between chart symbol and comparison symbol", group=g_general)
i_correlation_length = input.int(20, "Correlation Length", minval=5, maxval=50, tooltip="Period for correlation calculation", group=g_general)
i_min_correlation = input.float(0.5, "Minimum Correlation", minval=0, maxval=1, step=0.1, tooltip="Minimum correlation threshold for reliable signals", group=g_general)

// ============================================
// === MULTI-SYMBOL COMPARISON SETTINGS ======
// ============================================

g_multi_symbol = "🔄 Multi-Symbol Comparison Settings"
g_sym1 = "Symbol 1 Settings"
Sym1 = input.symbol('ES1!', 'Comparison Symbol 1', group=g_sym1)
i_enable_sym1 = input.bool(true, "Enable Symbol 1", tooltip="Enable or disable comparisons with Symbol 1", group=g_sym1)
i_sym1_weight = input.float(1.0, "Signal Weight", minval=0.1, maxval=5.0, step=0.1, tooltip="Weight of Symbol 1 signals (higher = more importance)", group=g_sym1)

g_sym2 = "Symbol 2 Settings"
Sym2 = input.symbol('NQ1!', 'Comparison Symbol 2', group=g_sym2)
i_enable_sym2 = input.bool(false, "Enable Symbol 2", tooltip="Enable or disable comparisons with Symbol 2", group=g_sym2)
i_sym2_weight = input.float(1.0, "Signal Weight", minval=0.1, maxval=5.0, step=0.1, tooltip="Weight of Symbol 2 signals (higher = more importance)", group=g_sym2)

g_sym3 = "Symbol 3 Settings"
Sym3 = input.symbol('YM1!', 'Comparison Symbol 3', group=g_sym3)
i_enable_sym3 = input.bool(false, "Enable Symbol 3", tooltip="Enable or disable comparisons with Symbol 3", group=g_sym3) 
i_sym3_weight = input.float(1.0, "Signal Weight", minval=0.1, maxval=5.0, step=0.1, tooltip="Weight of Symbol 3 signals (higher = more importance)", group=g_sym3)

g_multi_options = "Multi-Symbol Options"
i_signal_mode = input.string("Any", "Signal Generation Mode", options=["Any", "All", "Majority"], tooltip="Any: Signal if any symbol matches, All: Signal only if all symbols match, Majority: Signal if most symbols match", group=g_multi_options)
i_show_additional_symbols = input.bool(false, "Show Additional Symbols", tooltip="When enabled, additional symbols will be displayed according to Display Mode", group=g_multi_options)
i_multi_sym_display = input.string("Primary Only", "Display Mode", options=["Primary Only", "All Enabled", "Active Signal"], tooltip="Which comparison symbols to display on the chart", group=g_multi_options)
i_color_mode = input.string("Unique", "Color Mode", options=["Unique", "Signal Type"], tooltip="Unique: Each symbol has unique colors, Signal Type: Same colors for all symbols based on signal type", group=g_multi_options)

// Display Mode Group
g_display = "Display Mode"
i_mono_mode = input.bool(false, "Monochrome Mode", group=g_display)

// Timeframe Adaptation Settings
g_timeframe = "Timeframe Adaptation Settings"
i_auto_adapt = input.bool(true, "Auto-Adapt to Timeframe", tooltip="Automatically adjust bar lookback based on chart timeframe", group=g_timeframe)
i_lookback_multiplier = input.float(1.0, "Lookback Multiplier", minval=0.5, maxval=3.0, step=0.1, tooltip="Multiplier for auto-adaptation (higher = longer lookback)", group=g_timeframe)

// Custom timeframe settings (used when auto-adapt is disabled)
i_max_lookback = input.int(30, "Maximum Lookback Bars", minval=10, maxval=100, tooltip="Maximum number of bars to look back for divergence patterns", group=g_timeframe)
i_max_gap = input.int(30, "Maximum Bar Gap", minval=5, maxval=100, tooltip="Maximum distance between pivot points for valid divergence", group=g_timeframe)

// SMT Divergence Settings Group
g_smt = "SMT Divergence Settings"
g_smt_periods = "███ Fractal Periods"
n = input.int(2, title="Primary", inline="primary_fractal", group=g_smt_periods)
enablePrimaryFractal = input.bool(true, "Enable", inline="primary_fractal", group=g_smt_periods)

n2 = input.int(7, title="Secondary", inline="secondary_fractal", group=g_smt_periods)
enableSecondaryFractal = input.bool(false, "Enable", inline="secondary_fractal", group=g_smt_periods)

n3 = input.int(14, title="Tertiary", inline="tertiary_fractal", group=g_smt_periods)
enableTertiaryFractal = input.bool(false, "Enable", inline="tertiary_fractal", group=g_smt_periods)

// Divergence Type Settings
g_div_types = "███ Divergence Types"
i_regular_div = input.bool(true, "Regular Divergence", inline="div_types", tooltip="Show regular (reversal) divergences", group=g_div_types)
i_hidden_div = input.bool(false, "Hidden Divergence", inline="div_types", tooltip="Show hidden (continuation) divergences", group=g_div_types)

// Divergence Filtering
g_div_filter = "███ Divergence Filtering"
i_min_strength = input.float(0.0, "Minimum Strength (%)", minval=0.0, maxval=10.0, step=0.1, tooltip="Minimum percentage difference for valid divergence (0 = no filter)", group=g_div_filter)
i_use_volume_filter = input.bool(false, "Volume Confirmation", tooltip="Require increasing volume on pivot points", group=g_div_filter)

// SMT Visibility Settings
g_smt_visibility = "███ Visibility Controls"
Bull_Line = input.bool(true, 'Show Bullish Lines', inline="bull_controls", group=g_smt_visibility)
Bull_Label = input.bool(false, 'Show Bullish Labels', inline="bull_controls", group=g_smt_visibility)
Bear_Line = input.bool(true, 'Show Bearish Lines', inline="bear_controls", group=g_smt_visibility)
Bear_Label = input.bool(false, 'Show Bearish Labels', inline="bear_controls", group=g_smt_visibility)

// Line Display Settings
g_line_display = "███ Line Display Options"
i_show_on_main = input.bool(true, "Show Lines on Main Chart", tooltip="Display divergence lines on the main price chart", group=g_line_display)
i_show_on_indicator = input.bool(true, "Show Lines on Indicator", tooltip="Display divergence lines on this indicator panel", group=g_line_display)

// SMT Color Settings
g_smt_colors = "███ Divergence Colors"
// Primary divergence colors
i_primary_bull_color = input.color(#00FF00, "Primary Bullish", inline="primary_colors", group=g_smt_colors)
i_primary_bear_color = input.color(#FF0000, "Primary Bearish", inline="primary_colors", group=g_smt_colors)

// Secondary divergence colors
i_secondary_bull_color = input.color(#0000FF, "Secondary Bullish", inline="secondary_colors", group=g_smt_colors)
i_secondary_bear_color = input.color(#0000FF, "Secondary Bearish", inline="secondary_colors", group=g_smt_colors)

// Tertiary divergence colors
i_tertiary_bull_color = input.color(#800080, "Tertiary Bullish", inline="tertiary_colors", group=g_smt_colors)
i_tertiary_bear_color = input.color(#800080, "Tertiary Bearish", inline="tertiary_colors", group=g_smt_colors)

// Line Style Settings
g_line_style = "███ Line Style"
i_line_width = input.int(1, "Line Width", minval=1, maxval=4, inline="line_style", group=g_line_style)
i_line_style = input.string("Dashed", "Line Style", options=["Solid", "Dotted", "Dashed"], inline="line_style", group=g_line_style)
i_remove_old_lines = input.bool(true, "Remove Old Lines", tooltip="Automatically remove old divergence lines to improve performance", group=g_line_style)
i_max_lines = input.int(10, "Maximum Lines", minval=5, maxval=50, tooltip="Maximum number of divergence lines to display (oldest are removed first)", group=g_line_style)

// PSP Settings Group
g_psp = "PSP (Precision Swing Point) Settings"
g_psp_highlight = "███ Highlight Settings"
enableMarkGreen = input.bool(true, "Highlight Bullish PSP", inline="psp_enable", group=g_psp_highlight)
enableMarkRed = input.bool(true, "Highlight Bearish PSP", inline="psp_enable", group=g_psp_highlight)

markGreenColor = input.color(color.new(color.green, 0), "Bullish Color", inline="psp_colors", group=g_psp_highlight)
markRedColor = input.color(color.new(color.red, 0), "Bearish Color", inline="psp_colors", group=g_psp_highlight)

// PSP Border Settings
g_psp_border = "███ Border Settings"
i_enable_psp_borders = input.bool(true, "Show PSP Borders", inline="psp_border", group=g_psp_border)
pspBorderColorBullish = input.color(color.green, "Bullish Border", inline="psp_border_colors", group=g_psp_border)
pspBorderColorBearish = input.color(color.red, "Bearish Border", inline="psp_border_colors", group=g_psp_border)

// Swing Point Visualization Settings (Display Only)
g_psp_swing = "███ Swing Point Visualization"
i_show_swing_points = input.bool(false, "Show Swing Point Markers", tooltip="Display triangle markers at detected swing points", group=g_psp_swing)
i_bullish_swing_color = input.color(color.green, "Bullish Swing Mark Color", tooltip = "The color of a bullish swing mark (Green by default)" ,inline = "swing_mark_colors", group=g_psp_swing)
i_bearish_swing_color = input.color(color.red, "Bearish Swing Mark Color", tooltip = "The color of a bearish swing mark (Red by default)",inline = "swing_mark_colors", group=g_psp_swing)

// ENHANCED Swing Point Settings
g_swing_advanced = "███ Advanced Swing Point Settings"
i_check_entire_lookback = input.bool(true, "Check Entire Lookback Window", tooltip="Compare against all bars in lookback window instead of just adjacent bars", group=g_swing_advanced)
i_use_wicks = input.bool(true, "Use Wick Prices", tooltip="Use high/low (true) or open/close (false) for swing detection", group=g_swing_advanced)
i_use_atr_filter = input.bool(false, "Use ATR Filter", tooltip="Filter swing points based on ATR (Average True Range)", group=g_swing_advanced)
i_atr_multiplier = input.float(1.0, "ATR Multiplier", minval=0.5, maxval=3.0, step=0.1, tooltip="Multiply ATR by this value for filtering (higher = fewer signals)", group=g_swing_advanced)
i_atr_length = input.int(14, "ATR Length", minval=5, maxval=50, tooltip="Period for ATR calculation", group=g_swing_advanced)
i_avoid_overlap = input.bool(true, "Prevent Signal Overlap", tooltip="Prevent swing high and swing low signals from occurring on adjacent bars", group=g_swing_advanced)
i_visualize_strength = input.bool(false, "Visualize Swing Strength", tooltip="Show swing strength in labels", group=g_swing_advanced)
i_swing_lookback = input.int(1, "Swing Point Lookback", minval=1, maxval=5, tooltip="Number of bars to look back for swing point detection", group=g_swing_advanced)
i_swing_threshold = input.float(0.1, "Minimum Swing Threshold (%)", minval=0.0, maxval=5.0, step=0.1, tooltip="Minimum percentage difference required for a valid swing point (0 = no threshold)", group=g_swing_advanced)

// PSP Zone Settings
g_psp_zone = "███ PSP Zone Settings"
i_enable_psp_zones = input.bool(true, "Show PSP Zones", tooltip="Display zones between wick and body at swing points", group=g_psp_zone)
i_psp_zone_extend = input.int(3, "Zone Extension (Candles)", minval=1, maxval=20, tooltip="Number of candles to extend the PSP zone", group=g_psp_zone)
i_psp_zone_opacity = input.int(70, "Zone Opacity (%)", minval=10, maxval=100, tooltip="Transparency of PSP zones", group=g_psp_zone)
pspZoneColorBullish = input.color(color.green, "Bullish Zone Color", group=g_psp_zone)
pspZoneColorBearish = input.color(color.red, "Bearish Zone Color", group=g_psp_zone)

// Comparison Symbol Settings Group
g_comp = "Comparison Symbol Settings"
g_comp_candles = "███ Candle Display"
enableCompSymbolCandles = input.bool(true, "Show Comparison Candles", inline="comp_enable", group=g_comp_candles)
i_comp_opacity = input.int(100, "Opacity (%)", minval=0, maxval=100, inline="comp_enable", group=g_comp_candles)

// Candle Colors
g_comp_colors = "███ Candle Colors"
compSymbolBullishColor = input.color(#089981, "Bullish Body", inline="comp_bull_colors", group=g_comp_colors)
compSymbolBullishWickColor = input.color(#089981, "Bullish Wick", inline="comp_bull_colors", group=g_comp_colors)

compSymbolBearishColor = input.color(#f23645, "Bearish Body", inline="comp_bear_colors", group=g_comp_colors)
compSymbolBearishWickColor = input.color(#f23645, "Bearish Wick", inline="comp_bear_colors", group=g_comp_colors)

// Symbol-specific colors (for multi-symbol display)
g_sym_colors = "███ Symbol-Specific Colors"
compSymbol1BullishColor = input.color(#089981, "Symbol 1 Bullish", inline="sym1_colors", group=g_sym_colors)
compSymbol1BearishColor = input.color(#f23645, "Symbol 1 Bearish", inline="sym1_colors", group=g_sym_colors)

compSymbol2BullishColor = input.color(#4CAF50, "Symbol 2 Bullish", inline="sym2_colors", group=g_sym_colors)
compSymbol2BearishColor = input.color(#FF5722, "Symbol 2 Bearish", inline="sym2_colors", group=g_sym_colors)

compSymbol3BullishColor = input.color(#2196F3, "Symbol 3 Bullish", inline="sym3_colors", group=g_sym_colors)
compSymbol3BearishColor = input.color(#9C27B0, "Symbol 3 Bearish", inline="sym3_colors", group=g_sym_colors)

// Monochrome Mode Settings
g_mono = "Monochrome Mode Settings"
i_mono_bull_brightness = input.int(80, "Bullish Brightness", minval=0, maxval=100, inline="mono_brightness", group=g_mono)
i_mono_bear_brightness = input.int(20, "Bearish Brightness", minval=0, maxval=100, inline="mono_brightness", group=g_mono)

// Variables for PSP Zones
var box[] bullishZoneBoxes = array.new_box(0)
var box[] bearishZoneBoxes = array.new_box(0)

// ==========================================
// ===== HELPER FUNCTIONS =================
// ==========================================

// Calculate timeframe-specific bar lookback values
calcTimeframeAdaptiveValues() =>
    // Base multiplier for different timeframes
    float tfMultiplier = 1.0
    
    // Adjust multiplier based on timeframe
    if timeframe.isintraday
        if timeframe.in_seconds() <= 60 // 1-minute
            tfMultiplier := 0.5
        else if timeframe.in_seconds() <= 300 // 5-minute
            tfMultiplier := 0.75
        else if timeframe.in_seconds() <= 900 // 15-minute
            tfMultiplier := 1.0
        else if timeframe.in_seconds() <= 3600 // 1-hour
            tfMultiplier := 1.5
        else
            tfMultiplier := 2.0
    else if timeframe.isdaily
        tfMultiplier := 2.5
    else if timeframe.isweekly
        tfMultiplier := 3.0
    else if timeframe.ismonthly
        tfMultiplier := 4.0
    
    // Apply user's lookback multiplier
    tfMultiplier := tfMultiplier * i_lookback_multiplier
    
    // Calculate lookback and gap values
    int lookbackBars = math.round(30 * tfMultiplier)
    int maxGapBars = math.round(30 * tfMultiplier)
    
    [lookbackBars, maxGapBars]

// Get the lookback and gap values based on settings
[adaptiveLookback, adaptiveGap] = calcTimeframeAdaptiveValues()
int lookbackBars = i_auto_adapt ? adaptiveLookback : i_max_lookback
int maxGapBars = i_auto_adapt ? adaptiveGap : i_max_gap

// Function to convert color to monochrome based on brightness
getMonochromeColor(originalColor, brightness) =>
    if i_mono_mode
        monoValue = math.round(255 * brightness / 100)
        color.rgb(monoValue, monoValue, monoValue)
    else
        originalColor

// Function to get line style based on settings
getLineStyle() =>
    if i_line_style == "Solid"
        line.style_solid
    else if i_line_style == "Dotted"
        line.style_dotted
    else
        line.style_dashed

// Determine divergence colors based on mode and settings
getBullishDivergenceColor(level) =>
    if level == 1
        getMonochromeColor(i_primary_bull_color, i_mono_bull_brightness)
    else if level == 2
        getMonochromeColor(i_secondary_bull_color, i_mono_bull_brightness)
    else
        getMonochromeColor(i_tertiary_bull_color, i_mono_bull_brightness)

getBearishDivergenceColor(level) =>
    if level == 1
        getMonochromeColor(i_primary_bear_color, i_mono_bear_brightness)
    else if level == 2
        getMonochromeColor(i_secondary_bear_color, i_mono_bear_brightness)
    else
        getMonochromeColor(i_tertiary_bear_color, i_mono_bear_brightness)

// Calculate divergence strength
calculateDivergenceStrength(price1, price2, indicator1, indicator2) =>
    priceDiff = math.abs(price1 - price2) / math.max(price1, price2) * 100
    indicatorDiff = math.abs(indicator1 - indicator2) / math.max(math.abs(indicator1), math.abs(indicator2)) * 100
    
    // Return the combined strength
    (priceDiff + indicatorDiff) / 2

// Check if divergence meets minimum strength requirement
isDivergenceStrong(price1, price2, indicator1, indicator2) =>
    if i_min_strength <= 0
        true
    else
        strength = calculateDivergenceStrength(price1, price2, indicator1, indicator2)
        strength >= i_min_strength

// Function to manage box arrays
managePSPBoxes(box[] boxArray, int maxBoxes) =>
    if array.size(boxArray) > maxBoxes
        boxesToRemove = array.size(boxArray) - maxBoxes
        for i = 0 to boxesToRemove - 1
            oldBox = array.shift(boxArray)
            box.delete(oldBox)

// ==========================================
// ===== ENHANCED SWING POINT DETECTION ===
// ==========================================

// Enhanced swing detection function
enhancedSwingHigh(lookback, threshold) =>
    if bar_index < lookback
        false
    else
        // Determine which price to use based on setting
        highPrice = i_use_wicks ? high : math.max(open, close)
        
        // Advanced detection: check entire lookback window if enabled
        isHighPoint = true
        
        if i_check_entire_lookback
            // Check if higher than all bars in lookback window
            for i = 1 to lookback
                // Check left side
                if highPrice[lookback] <= highPrice[lookback + i]
                    isHighPoint := false
                    break
            
            // Only check right side if left side passed
            if isHighPoint and bar_index >= lookback + lookback
                for i = 1 to lookback
                    // Check right side (if we have enough bars)
                    if highPrice[lookback] <= highPrice[lookback - i]
                        isHighPoint := false
                        break
        else
            // Simplified check against just adjacent bars
            isHighPoint := highPrice[lookback] > highPrice[lookback - 1] and highPrice[lookback] > highPrice[lookback + 1]
        
        // Apply threshold if enabled
        if threshold > 0 and isHighPoint
            thresholdValue = close[lookback] * threshold / 100
            
            // Find the highest surrounding high (excluding current bar)
            surroundingMax = -1.0 * float(na)
            if i_check_entire_lookback
                for i = 1 to lookback
                    // Check left side
                    if i <= lookback
                        surroundingMax := math.max(nz(surroundingMax, highPrice[lookback + i]), highPrice[lookback + i])
                    
                    // Check right side (if we have enough bars)
                    if bar_index >= lookback + i
                        surroundingMax := math.max(nz(surroundingMax, highPrice[lookback - i]), highPrice[lookback - i])
            else
                surroundingMax := math.max(highPrice[lookback - 1], highPrice[lookback + 1])
            
            // Check if difference exceeds threshold
            isHighPoint := isHighPoint and (highPrice[lookback] - nz(surroundingMax, 0)) >= thresholdValue
        
        // Apply ATR filter if enabled
        if i_use_atr_filter and isHighPoint
            atr = ta.atr(i_atr_length)
            atrThreshold = atr * i_atr_multiplier
            
            // Find adjacent low for measuring swing height
            adjacentLow = math.min(low[lookback - 1], low[lookback + 1])
            swingHeight = highPrice[lookback] - adjacentLow
            
            // Filter out swings smaller than ATR threshold
            isHighPoint := isHighPoint and swingHeight >= atrThreshold
        
        isHighPoint

enhancedSwingLow(lookback, threshold) =>
    if bar_index < lookback
        false
    else
        // Determine which price to use based on setting
        lowPrice = i_use_wicks ? low : math.min(open, close)
        
        // Advanced detection: check entire lookback window if enabled
        isLowPoint = true
        
        if i_check_entire_lookback
            // Check if lower than all bars in lookback window
            for i = 1 to lookback
                // Check left side
                if lowPrice[lookback] >= lowPrice[lookback + i]
                    isLowPoint := false
                    break
            
            // Only check right side if left side passed
            if isLowPoint and bar_index >= lookback + lookback
                for i = 1 to lookback
                    // Check right side (if we have enough bars)
                    if lowPrice[lookback] >= lowPrice[lookback - i]
                        isLowPoint := false
                        break
        else
            // Simplified check against just adjacent bars
            isLowPoint := lowPrice[lookback] < lowPrice[lookback - 1] and 
                       lowPrice[lookback] < lowPrice[lookback + 1]
        
        // Apply threshold if enabled
        if threshold > 0 and isLowPoint
            thresholdValue = close[lookback] * threshold / 100
            
            // Find the lowest surrounding low (excluding current bar)
            surroundingMin = float(na)
            if i_check_entire_lookback
                for i = 1 to lookback
                    // Check left side
                    if i <= lookback
                        currentValue = lowPrice[lookback + i]
                        surroundingMin := na(surroundingMin) ? currentValue : math.min(surroundingMin, currentValue)
                    
                    // Check right side (if we have enough bars)
                    if bar_index >= lookback + i
                        currentValue = lowPrice[lookback - i]
                        surroundingMin := na(surroundingMin) ? currentValue : math.min(surroundingMin, currentValue)
            else
                surroundingMin := math.min(lowPrice[lookback - 1], lowPrice[lookback + 1])
            
            // Check if difference exceeds threshold
            isLowPoint := isLowPoint and (nz(surroundingMin, 9999999) - lowPrice[lookback]) >= thresholdValue
        
        // Apply ATR filter if enabled
        if i_use_atr_filter and isLowPoint
            atr = ta.atr(i_atr_length)
            atrThreshold = atr * i_atr_multiplier
            
            // Find adjacent high for measuring swing depth
            adjacentHigh = math.max(high[lookback - 1], high[lookback + 1])
            swingDepth = adjacentHigh - lowPrice[lookback]
            
            // Filter out swings smaller than ATR threshold
            isLowPoint := isLowPoint and swingDepth >= atrThreshold
        
        isLowPoint

// Enhanced functions to avoid overlapping signals
enhancedSHX(lookback, threshold) =>
    highCondition = enhancedSwingHigh(lookback, threshold)
    
    if i_avoid_overlap and highCondition and bar_index >= lookback + 1
        // Make sure there's not a swing low on adjacent bars
        noLowOverlap = not enhancedSwingLow(lookback - 1, threshold) and 
                     not enhancedSwingLow(lookback + 1, threshold)
        highCondition and noLowOverlap
    else
        highCondition

enhancedSLX(lookback, threshold) =>
    lowCondition = enhancedSwingLow(lookback, threshold)
    
    if i_avoid_overlap and lowCondition and bar_index >= lookback + 1
        // Make sure there's not a swing high on adjacent bars
        noHighOverlap = not enhancedSwingHigh(lookback - 1, threshold) and 
                      not enhancedSwingHigh(lookback + 1, threshold)
        lowCondition and noHighOverlap
    else
        lowCondition

// Calculate swing strength (for visualization or filtering)
calculateSwingStrength(isHigh, lookback) =>
    if bar_index < lookback
        0.0
    else
        // Calculate ATR for normalization
        atr = ta.atr(i_atr_length)
        
        // Determine which price to use
        highPrice = i_use_wicks ? high : math.max(open, close)
        lowPrice = i_use_wicks ? low : math.min(open, close)
        
        if isHigh
            // For swing highs: measure height as % of ATR
            swingHeight = highPrice[lookback] - math.min(low[lookback-1], low[lookback+1])
            swingHeight / atr
        else
            // For swing lows: measure depth as % of ATR
            swingDepth = math.max(high[lookback-1], high[lookback+1]) - lowPrice[lookback]
            swingDepth / atr

// Detect swing points using enhanced detection
isSwingLow = enhancedSLX(i_swing_lookback, i_swing_threshold)
isSwingHigh = enhancedSHX(i_swing_lookback, i_swing_threshold)

// Calculate strength for visualization
swingLowStrength = isSwingLow ? calculateSwingStrength(false, i_swing_lookback) : 0
swingHighStrength = isSwingHigh ? calculateSwingStrength(true, i_swing_lookback) : 0

// ==========================================
// ===== MULTI-SYMBOL DATA RETRIEVAL =======
// ==========================================

// Current chart timeframe
currentChartTimeframe = timeframe.period

// Retrieve data for the current chart's symbol
chartSymbolClose = close
chartSymbolOpen = open
chartSymbolVolume = volume

// Retrieve data for Symbol 1
compSymbol1Close = i_enable_sym1 ? request.security(Sym1, currentChartTimeframe, close, gaps=barmerge.gaps_off) : na
compSymbol1Open = i_enable_sym1 ? request.security(Sym1, currentChartTimeframe, open, gaps=barmerge.gaps_off) : na
compSymbol1High = i_enable_sym1 ? request.security(Sym1, currentChartTimeframe, high, gaps=barmerge.gaps_off) : na
compSymbol1Low = i_enable_sym1 ? request.security(Sym1, currentChartTimeframe, low, gaps=barmerge.gaps_off) : na
compSymbol1Volume = i_enable_sym1 ? request.security(Sym1, currentChartTimeframe, volume, gaps=barmerge.gaps_off) : na

// Retrieve data for Symbol 2
compSymbol2Close = i_enable_sym2 ? request.security(Sym2, currentChartTimeframe, close, gaps=barmerge.gaps_off) : na
compSymbol2Open = i_enable_sym2 ? request.security(Sym2, currentChartTimeframe, open, gaps=barmerge.gaps_off) : na
compSymbol2High = i_enable_sym2 ? request.security(Sym2, currentChartTimeframe, high, gaps=barmerge.gaps_off) : na
compSymbol2Low = i_enable_sym2 ? request.security(Sym2, currentChartTimeframe, low, gaps=barmerge.gaps_off) : na
compSymbol2Volume = i_enable_sym2 ? request.security(Sym2, currentChartTimeframe, volume, gaps=barmerge.gaps_off) : na

// Retrieve data for Symbol 3
compSymbol3Close = i_enable_sym3 ? request.security(Sym3, currentChartTimeframe, close, gaps=barmerge.gaps_off) : na
compSymbol3Open = i_enable_sym3 ? request.security(Sym3, currentChartTimeframe, open, gaps=barmerge.gaps_off) : na
compSymbol3High = i_enable_sym3 ? request.security(Sym3, currentChartTimeframe, high, gaps=barmerge.gaps_off) : na
compSymbol3Low = i_enable_sym3 ? request.security(Sym3, currentChartTimeframe, low, gaps=barmerge.gaps_off) : na
compSymbol3Volume = i_enable_sym3 ? request.security(Sym3, currentChartTimeframe, volume, gaps=barmerge.gaps_off) : na

// Calculate correlations between the chart symbol and comparison symbols
correlation1 = i_enable_sym1 ? ta.correlation(close, compSymbol1Close, i_correlation_length) : 0
correlation2 = i_enable_sym2 ? ta.correlation(close, compSymbol2Close, i_correlation_length) : 0
correlation3 = i_enable_sym3 ? ta.correlation(close, compSymbol3Close, i_correlation_length) : 0

// Check if correlations are valid
isCorrelationValid1 = i_enable_sym1 ? (correlation1 >= i_min_correlation or correlation1 <= -i_min_correlation) : false
isCorrelationValid2 = i_enable_sym2 ? (correlation2 >= i_min_correlation or correlation2 <= -i_min_correlation) : false
isCorrelationValid3 = i_enable_sym3 ? (correlation3 >= i_min_correlation or correlation3 <= -i_min_correlation) : false

// ==========================================
// ===== MULTI-SYMBOL PSP DETECTION =======
// ==========================================

// Check candle directions for main symbol
isGreenChartSymbol = chartSymbolClose > chartSymbolOpen
isRedChartSymbol = chartSymbolClose < chartSymbolOpen

// Check directions for Symbol 1
isGreenCompSymbol1 = compSymbol1Close > compSymbol1Open
isRedCompSymbol1 = compSymbol1Close < compSymbol1Open

// Check directions for Symbol 2
isGreenCompSymbol2 = compSymbol2Close > compSymbol2Open
isRedCompSymbol2 = compSymbol2Close < compSymbol2Open

// Check directions for Symbol 3
isGreenCompSymbol3 = compSymbol3Close > compSymbol3Open
isRedCompSymbol3 = compSymbol3Close < compSymbol3Open

// Individual PSP signals for each symbol
markGreen1 = i_enable_sym1 and enableMarkGreen and isRedCompSymbol1 and isGreenChartSymbol
markRed1 = i_enable_sym1 and enableMarkRed and isGreenCompSymbol1 and isRedChartSymbol

markGreen2 = i_enable_sym2 and enableMarkGreen and isRedCompSymbol2 and isGreenChartSymbol
markRed2 = i_enable_sym2 and enableMarkRed and isGreenCompSymbol2 and isRedChartSymbol

markGreen3 = i_enable_sym3 and enableMarkGreen and isRedCompSymbol3 and isGreenChartSymbol
markRed3 = i_enable_sym3 and enableMarkRed and isGreenCompSymbol3 and isRedChartSymbol

// Count the number of active comparison symbols
activeSymbolCount = (i_enable_sym1 ? 1 : 0) + (i_enable_sym2 ? 1 : 0) + (i_enable_sym3 ? 1 : 0)

// Count the number of bullish and bearish signals
bullishSignalCount = (markGreen1 ? 1 : 0) + (markGreen2 ? 1 : 0) + (markGreen3 ? 1 : 0)
bearishSignalCount = (markRed1 ? 1 : 0) + (markRed2 ? 1 : 0) + (markRed3 ? 1 : 0)

// Weighted signal calculation
weightedBullishSignalCount = (markGreen1 ? i_sym1_weight : 0) + (markGreen2 ? i_sym2_weight : 0) + (markGreen3 ? i_sym3_weight : 0)
weightedBearishSignalCount = (markRed1 ? i_sym1_weight : 0) + (markRed2 ? i_sym2_weight : 0) + (markRed3 ? i_sym3_weight : 0)
totalWeights = (i_enable_sym1 ? i_sym1_weight : 0) + (i_enable_sym2 ? i_sym2_weight : 0) + (i_enable_sym3 ? i_sym3_weight : 0)
weightedMajorityThreshold = totalWeights * 0.5

// Combined PSP signals based on selected mode
markGreen = activeSymbolCount > 0 and ((i_signal_mode == "Any" and bullishSignalCount > 0) or (i_signal_mode == "All" and bullishSignalCount == activeSymbolCount) or (i_signal_mode == "Majority" and weightedBullishSignalCount > weightedMajorityThreshold))
markRed = activeSymbolCount > 0 and ((i_signal_mode == "Any" and bearishSignalCount > 0) or (i_signal_mode == "All" and bearishSignalCount == activeSymbolCount) or (i_signal_mode == "Majority" and weightedBearishSignalCount > weightedMajorityThreshold))

// Debug logging for swing points
if isSwingLow
    log.info("Swing Low Detected at Bar Index: {0}, Time: {1}, Price: {2}, Strength: {3}", bar_index, time, low[i_swing_lookback], swingLowStrength)

// Debug log for Swing High Points
if isSwingHigh
    log.info("Swing High Detected at Bar Index: {0}, Time: {1}, Price: {2}, Strength: {3}", bar_index, time, high[i_swing_lookback], swingHighStrength)

// ==========================================
// ===== PSP ZONE MANAGEMENT ==============
// ==========================================

// Set maximum number of boxes to maintain performance
maxPSPBoxes = 20

// Clean up old boxes to maintain performance
managePSPBoxes(bullishZoneBoxes, maxPSPBoxes)
managePSPBoxes(bearishZoneBoxes, maxPSPBoxes)

// Detailed PSP Green (Bullish) Signal Logging
if markGreen
    log.info("Bullish PSP Signal Detected")
    log.info("Main Chart Symbol: Close {0}, Open {1}", chartSymbolClose, chartSymbolOpen)
    if i_enable_sym1
        log.info("Symbol 1: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol1Close, compSymbol1Open, correlation1, markGreen1 ? "Bullish" : "None")
    if i_enable_sym2
        log.info("Symbol 2: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol2Close, compSymbol2Open, correlation2, markGreen2 ? "Bullish" : "None")
    if i_enable_sym3
        log.info("Symbol 3: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol3Close, compSymbol3Open, correlation3, markGreen3 ? "Bullish" : "None")

// Detailed PSP Red (Bearish) Signal Logging
if markRed
    log.info("Bearish PSP Signal Detected")
    log.info("Main Chart Symbol: Close {0}, Open {1}", chartSymbolClose, chartSymbolOpen)
    if i_enable_sym1
        log.info("Symbol 1: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol1Close, compSymbol1Open, correlation1, markRed1 ? "Bearish" : "None")
    if i_enable_sym2
        log.info("Symbol 2: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol2Close, compSymbol2Open, correlation2, markRed2 ? "Bearish" : "None")
    if i_enable_sym3
        log.info("Symbol 3: Close {0}, Open {1}, Correlation: {2}, Signal: {3}", compSymbol3Close, compSymbol3Open, correlation3, markRed3 ? "Bearish" : "None")

// Create new bullish PSP zone 
if markGreen and i_enable_psp_zones
    bodyBottom = math.min(open, close)
    wickBottom = low
    zoneStart = bar_index
    zoneEnd = bar_index + i_psp_zone_extend
    
    // Create a box for the zone - exactly from body bottom to wick bottom
    zoneColor = i_mono_mode ? color.new(getMonochromeColor(pspZoneColorBullish, i_mono_bull_brightness), 100 - i_psp_zone_opacity) : color.new(pspZoneColorBullish, 100 - i_psp_zone_opacity)
    
    // The box needs left, top, right, bottom coordinates
    zoneBox = box.new(left=zoneStart, top=bodyBottom, right=zoneEnd, bottom=wickBottom, bgcolor=zoneColor, border_color=na, force_overlay=true)
    array.push(bullishZoneBoxes, zoneBox)

// Create new bearish PSP zone (top of body to wick) for bearish PSP 
if markRed and i_enable_psp_zones
    bodyTop = math.max(open, close)
    wickTop = high
    zoneStart = bar_index
    zoneEnd = bar_index + i_psp_zone_extend
    
    // Create a box for the zone - exactly from body top to wick top
    zoneColor = i_mono_mode ? color.new(getMonochromeColor(pspZoneColorBearish, i_mono_bear_brightness), 100 - i_psp_zone_opacity) : color.new(pspZoneColorBearish, 100 - i_psp_zone_opacity)
    
    // The box needs left, top, right, bottom coordinates
    zoneBox = box.new(left=zoneStart, top=wickTop, right=zoneEnd, bottom=bodyTop, bgcolor=zoneColor, border_color=na, force_overlay=true)
    array.push(bearishZoneBoxes, zoneBox)

// Apply monochrome colors if needed
pspBullishBorderColor = getMonochromeColor(pspBorderColorBullish, i_mono_bull_brightness)
pspBearishBorderColor = getMonochromeColor(pspBorderColorBearish, i_mono_bear_brightness)

// ==========================================
// === SMT DIVERGENCE DETECTION ============
// ==========================================

// Select the primary comparison symbol for SMT divergence analysis
// We use the first enabled symbol, with priority: Symbol1 > Symbol2 > Symbol3
primarySymbol = i_enable_sym1 ? Sym1 : (i_enable_sym2 ? Sym2 : (i_enable_sym3 ? Sym3 : Sym1))

// SMT Divergence Fractals for the selected primary symbol
[Open, High, Low, Close] = request.security(primarySymbol, timeframe.period, [open, high, low, close], gaps=barmerge.gaps_off)
Volume = request.security(primarySymbol, timeframe.period, volume, gaps=barmerge.gaps_off)

// Primary Fractal
UpPivot = bool(ta.pivothigh(n,n)) and enablePrimaryFractal
DownPivot = bool(ta.pivotlow(n,n)) and enablePrimaryFractal

// Secondary Fractal
UpPivot2 = enableSecondaryFractal ? bool(ta.pivothigh(n2,n2)) : false
DownPivot2 = enableSecondaryFractal ? bool(ta.pivotlow(n2,n2)) : false

// Tertiary Fractal
UpPivot3 = enableTertiaryFractal ? bool(ta.pivothigh(n3,n3)) : false
DownPivot3 = enableTertiaryFractal ? bool(ta.pivotlow(n3,n3)) : false

// ==========================================
// == BEARISH DIVERGENCE DETECTION =========
// ==========================================

// Bearish Divergence Data - Primary
High_Last_Price = ta.valuewhen(UpPivot, high[n], 0)
High_Per_Price = ta.valuewhen(UpPivot, high[n], 1)
High_Last_Hist = ta.valuewhen(UpPivot, High[n], 0)
High_Per_Hist = ta.valuewhen(UpPivot, High[n], 1)
High_Last_Bar = ta.valuewhen(UpPivot, bar_index[n], 0)
High_Per_Bar = ta.valuewhen(UpPivot, bar_index[n], 1)
High_Last_Vol = ta.valuewhen(UpPivot, Volume[n], 0) 
High_Per_Vol = ta.valuewhen(UpPivot, Volume[n], 1)
Time_Condition_Bear = (High_Last_Bar + lookbackBars) > bar_index

// Bearish Divergence Data - Secondary
High_Last_Price2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, high[n2], 0) : na
High_Per_Price2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, high[n2], 1) : na
High_Last_Hist2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, High[n2], 0) : na
High_Per_Hist2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, High[n2], 1) : na
High_Last_Bar2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, bar_index[n2], 0) : na
High_Per_Bar2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, bar_index[n2], 1) : na
High_Last_Vol2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, Volume[n2], 0) : na
High_Per_Vol2 = enableSecondaryFractal ? ta.valuewhen(UpPivot2, Volume[n2], 1) : na
Time_Condition_Bear2 = enableSecondaryFractal ? (High_Last_Bar2 + lookbackBars) > bar_index : false

// Bearish Divergence Data - Tertiary
High_Last_Price3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, high[n3], 0) : na
High_Per_Price3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, high[n3], 1) : na
High_Last_Hist3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, High[n3], 0) : na
High_Per_Hist3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, High[n3], 1) : na
High_Last_Bar3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, bar_index[n3], 0) : na
High_Per_Bar3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, bar_index[n3], 1) : na
High_Last_Vol3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, Volume[n3], 0) : na
High_Per_Vol3 = enableTertiaryFractal ? ta.valuewhen(UpPivot3, Volume[n3], 1) : na
Time_Condition_Bear3 = enableTertiaryFractal ? (High_Last_Bar3 + lookbackBars) > bar_index : false

// Improved Bearish Divergence Detector - Primary
Last_Bearish_Divergece = if High_Last_Hist > 0 and High_Per_Hist > 0 and Time_Condition_Bear and (High_Last_Bar - High_Per_Bar) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? High_Last_Vol > High_Per_Vol : true
    
    // Regular bearish divergence (price higher, indicator lower)
    regularDiv = i_regular_div and High_Last_Price > High_Per_Price and High_Last_Hist < High_Per_Hist and volumeCheck
    
    // Hidden bearish divergence (price lower, indicator higher)
    hiddenDiv = i_hidden_div and High_Last_Price < High_Per_Price and High_Last_Hist > High_Per_Hist and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(High_Last_Price, High_Per_Price, High_Last_Hist, High_Per_Hist)
    
    (regularDiv or hiddenDiv) and isStrong
else 
    false

// Improved Bearish Divergence Detector - Secondary
Last_Bearish_Divergece2 = if enableSecondaryFractal and High_Last_Hist2 > 0 and High_Per_Hist2 > 0 and Time_Condition_Bear2 and (High_Last_Bar2 - High_Per_Bar2) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? High_Last_Vol2 > High_Per_Vol2 : true
    
    // Regular bearish divergence (price higher, indicator lower)
    regularDiv = i_regular_div and High_Last_Price2 > High_Per_Price2 and High_Last_Hist2 < High_Per_Hist2 and volumeCheck
    
    // Hidden bearish divergence (price lower, indicator higher)
    hiddenDiv = i_hidden_div and High_Last_Price2 < High_Per_Price2 and High_Last_Hist2 > High_Per_Hist2 and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(High_Last_Price2, High_Per_Price2, High_Last_Hist2, High_Per_Hist2)
    
    (regularDiv or hiddenDiv) and isStrong
else
    false

// Improved Bearish Divergence Detector - Tertiary
Last_Bearish_Divergece3 = if enableTertiaryFractal and High_Last_Hist3 > 0 and High_Per_Hist3 > 0 and Time_Condition_Bear3 and (High_Last_Bar3 - High_Per_Bar3) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? High_Last_Vol3 > High_Per_Vol3 : true
    
    // Regular bearish divergence (price higher, indicator lower)
    regularDiv = i_regular_div and High_Last_Price3 > High_Per_Price3 and High_Last_Hist3 < High_Per_Hist3 and volumeCheck
    
    // Hidden bearish divergence (price lower, indicator higher)
    hiddenDiv = i_hidden_div and High_Last_Price3 < High_Per_Price3 and High_Last_Hist3 > High_Per_Hist3 and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(High_Last_Price3, High_Per_Price3, High_Last_Hist3, High_Per_Hist3)
    
    (regularDiv or hiddenDiv) and isStrong
else
    false

// ==========================================
// == BULLISH DIVERGENCE DETECTION =========
// ==========================================

// Bullish Divergence Data - Primary
Low_Last_Price = ta.valuewhen(DownPivot, low[n], 0)
Low_Per_Price = ta.valuewhen(DownPivot, low[n], 1)
Low_Last_Hist = ta.valuewhen(DownPivot, Low[n], 0)
Low_Per_Hist = ta.valuewhen(DownPivot, Low[n], 1)
Low_Last_Bar = ta.valuewhen(DownPivot, bar_index[n], 0)
Low_Per_Bar = ta.valuewhen(DownPivot, bar_index[n], 1)
Low_Last_Vol = ta.valuewhen(DownPivot, Volume[n], 0)
Low_Per_Vol = ta.valuewhen(DownPivot, Volume[n], 1)
Time_Condition_Bull = (Low_Last_Bar + lookbackBars) > bar_index 

// Bullish Divergence Data - Secondary
Low_Last_Price2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, low[n2], 0) : na
Low_Per_Price2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, low[n2], 1) : na
Low_Last_Hist2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, Low[n2], 0) : na
Low_Per_Hist2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, Low[n2], 1) : na
Low_Last_Bar2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, bar_index[n2], 0) : na
Low_Per_Bar2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, bar_index[n2], 1) : na
Low_Last_Vol2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, Volume[n2], 0) : na
Low_Per_Vol2 = enableSecondaryFractal ? ta.valuewhen(DownPivot2, Volume[n2], 1) : na
Time_Condition_Bull2 = enableSecondaryFractal ? (Low_Last_Bar2 + lookbackBars) > bar_index : false

// Bullish Divergence Data - Tertiary
Low_Last_Price3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, low[n3], 0) : na
Low_Per_Price3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, low[n3], 1) : na
Low_Last_Hist3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, Low[n3], 0) : na
Low_Per_Hist3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, Low[n3], 1) : na
Low_Last_Bar3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, bar_index[n3], 0) : na
Low_Per_Bar3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, bar_index[n3], 1) : na
Low_Last_Vol3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, Volume[n3], 0) : na
Low_Per_Vol3 = enableTertiaryFractal ? ta.valuewhen(DownPivot3, Volume[n3], 1) : na
Time_Condition_Bull3 = enableTertiaryFractal ? (Low_Last_Bar3 + lookbackBars) > bar_index : false

// Improved Bullish Divergence Detector - Primary
Last_Bullish_Divergece = if Low_Last_Hist > 0 and Low_Per_Hist > 0 and Time_Condition_Bull and (Low_Last_Bar - Low_Per_Bar) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? Low_Last_Vol > Low_Per_Vol : true
    
    // Regular bullish divergence (price lower, indicator higher)
    regularDiv = i_regular_div and Low_Last_Price < Low_Per_Price and Low_Last_Hist > Low_Per_Hist and volumeCheck
    
    // Hidden bullish divergence (price higher, indicator lower)
    hiddenDiv = i_hidden_div and Low_Last_Price > Low_Per_Price and Low_Last_Hist < Low_Per_Hist and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(Low_Last_Price, Low_Per_Price, Low_Last_Hist, Low_Per_Hist)
    
    (regularDiv or hiddenDiv) and isStrong
else 
    false

// Improved Bullish Divergence Detector - Secondary
Last_Bullish_Divergece2 = if enableSecondaryFractal and Low_Last_Hist2 > 0 and Low_Per_Hist2 > 0 and Time_Condition_Bull2 and (Low_Last_Bar2 - Low_Per_Bar2) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? Low_Last_Vol2 > Low_Per_Vol2 : true
    
    // Regular bullish divergence (price lower, indicator higher)
    regularDiv = i_regular_div and Low_Last_Price2 < Low_Per_Price2 and Low_Last_Hist2 > Low_Per_Hist2 and volumeCheck
    
    // Hidden bullish divergence (price higher, indicator lower)
    hiddenDiv = i_hidden_div and Low_Last_Price2 > Low_Per_Price2 and Low_Last_Hist2 < Low_Per_Hist2 and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(Low_Last_Price2, Low_Per_Price2, Low_Last_Hist2, Low_Per_Hist2)
    
    (regularDiv or hiddenDiv) and isStrong
else
    false

// Improved Bullish Divergence Detector - Tertiary
Last_Bullish_Divergece3 = if enableTertiaryFractal and Low_Last_Hist3 > 0 and Low_Per_Hist3 > 0 and Time_Condition_Bull3 and (Low_Last_Bar3 - Low_Per_Bar3) < maxGapBars
    // Check volume condition if enabled
    volumeCheck = i_use_volume_filter ? Low_Last_Vol3 > Low_Per_Vol3 : true
    
    // Regular bullish divergence (price lower, indicator higher)
    regularDiv = i_regular_div and Low_Last_Price3 < Low_Per_Price3 and Low_Last_Hist3 > Low_Per_Hist3 and volumeCheck
    
    // Hidden bullish divergence (price higher, indicator lower)
    hiddenDiv = i_hidden_div and Low_Last_Price3 > Low_Per_Price3 and Low_Last_Hist3 < Low_Per_Hist3 and volumeCheck
    
    // Check strength
    isStrong = isDivergenceStrong(Low_Last_Price3, Low_Per_Price3, Low_Last_Hist3, Low_Per_Hist3)
    
    (regularDiv or hiddenDiv) and isStrong
else
    false

// ==========================================
// === VISUAL COMPONENTS ===================
// ==========================================

// Determine border colors for Symbol 1
compSymbol1BorderColor() =>
    // Check if PSP conditions are met for Symbol 1
    isPSPGreen1 = isRedCompSymbol1 and isGreenChartSymbol
    isPSPRed1 = isGreenCompSymbol1 and isRedChartSymbol
    isPrimarySymbol1 = i_enable_sym1 and not i_enable_sym2 and not i_enable_sym3
    
    if enableCompSymbolCandles and i_enable_psp_borders and (isPrimarySymbol1 or (i_show_additional_symbols and (i_multi_sym_display == "ALL_ENABLED" or i_multi_sym_display == "ACTIVE_SIGNAL" and (isPSPGreen1 or isPSPRed1))))
        if isPSPGreen1
            if i_mono_mode
                getMonochromeColor(color.white, math.max(10, i_mono_bull_brightness - 50))
            else
                pspBullishBorderColor
        else if isPSPRed1
            if i_mono_mode
                getMonochromeColor(color.white, math.min(90, i_mono_bear_brightness + 50))
            else
                pspBearishBorderColor
        else
            if i_color_mode == "UNIQUE"
                i_mono_mode ? compSymbol1Close >= compSymbol1Open ? getMonochromeColor(compSymbol1BullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbol1BearishColor, i_mono_bear_brightness) : compSymbol1Close >= compSymbol1Open ? compSymbol1BullishColor : compSymbol1BearishColor
            else
                i_mono_mode ? Close >= Open ? getMonochromeColor(compSymbolBullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbolBearishColor, i_mono_bear_brightness) : Close >= Open ? compSymbolBullishColor : compSymbolBearishColor
    else
        na

// Determine border colors for Symbol 2
compSymbol2BorderColor() =>
    // Check if PSP conditions are met for Symbol 2
    isPSPGreen2 = isRedCompSymbol2 and isGreenChartSymbol
    isPSPRed2 = isGreenCompSymbol2 and isRedChartSymbol
    isPrimarySymbol2 = not i_enable_sym1 and i_enable_sym2 and not i_enable_sym3
    
    if enableCompSymbolCandles and i_enable_psp_borders and (isPrimarySymbol2 or (i_show_additional_symbols and (i_multi_sym_display == "ALL_ENABLED" or i_multi_sym_display == "ACTIVE_SIGNAL" and (isPSPGreen2 or isPSPRed2))))
        if isPSPGreen2
            if i_mono_mode
                getMonochromeColor(color.white, math.max(10, i_mono_bull_brightness - 50))
            else
                pspBullishBorderColor
        else if isPSPRed2
            if i_mono_mode
                getMonochromeColor(color.white, math.min(90, i_mono_bear_brightness + 50))
            else
                pspBearishBorderColor
        else
            if i_color_mode == "UNIQUE"
                i_mono_mode ? compSymbol2Close >= compSymbol2Open ? getMonochromeColor(compSymbol2BullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbol2BearishColor, i_mono_bear_brightness) : compSymbol2Close >= compSymbol2Open ? compSymbol2BullishColor : compSymbol2BearishColor
            else
                i_mono_mode ? Close >= Open ? getMonochromeColor(compSymbolBullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbolBearishColor, i_mono_bear_brightness) : Close >= Open ? compSymbolBullishColor : compSymbolBearishColor
    else
        na

// Determine border colors for Symbol 3
compSymbol3BorderColor() =>
    // Check if PSP conditions are met for Symbol 3
    isPSPGreen3 = isRedCompSymbol3 and isGreenChartSymbol
    isPSPRed3 = isGreenCompSymbol3 and isRedChartSymbol
    isPrimarySymbol3 = not i_enable_sym1 and not i_enable_sym2 and i_enable_sym3
    
    if enableCompSymbolCandles and i_enable_psp_borders and (isPrimarySymbol3 or (i_show_additional_symbols and (i_multi_sym_display == "ALL_ENABLED" or i_multi_sym_display == "ACTIVE_SIGNAL" and (isPSPGreen3 or isPSPRed3))))
        if isPSPGreen3
            if i_mono_mode
                getMonochromeColor(color.white, math.max(10, i_mono_bull_brightness - 50))
            else
                pspBullishBorderColor
        else if isPSPRed3
            if i_mono_mode
                getMonochromeColor(color.white, math.min(90, i_mono_bear_brightness + 50))
            else
                pspBearishBorderColor
        else
            if i_color_mode == "UNIQUE"
                i_mono_mode ? compSymbol3Close >= compSymbol3Open ? getMonochromeColor(compSymbol3BullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbol3BearishColor, i_mono_bear_brightness) : compSymbol3Close >= compSymbol3Open ? compSymbol3BullishColor : compSymbol3BearishColor
            else
                i_mono_mode ? Close >= Open ? getMonochromeColor(compSymbolBullishColor, i_mono_bull_brightness) : getMonochromeColor(compSymbolBearishColor, i_mono_bear_brightness) : Close >= Open ? compSymbolBullishColor : compSymbolBearishColor
    else
        na

// Main Chart Border Color
mainChartBorderColor() =>
    if markGreen
        // In monochrome mode, use contrasting border for main chart PSP candles
        if i_mono_mode
            // For bullish PSP, use darker border on lighter candle
            getMonochromeColor(color.white, math.max(10, i_mono_bull_brightness - 50))
        else
            pspBullishBorderColor
    else if markRed
        // In monochrome mode, use contrasting border for main chart PSP candles
        if i_mono_mode
            // For bearish PSP, use lighter border on darker candle
            getMonochromeColor(color.white, math.min(90, i_mono_bear_brightness + 50))
        else
            pspBearishBorderColor
    else
        na

// Line arrays for managing divergence lines
var line[] bullishLines = array.new_line()
var line[] bearishLines = array.new_line()
var line[] bullishIndicatorLines = array.new_line()
var line[] bearishIndicatorLines = array.new_line()

// Function to manage line arrays
manageLinesArray(line[] arr) =>
    if i_remove_old_lines and array.size(arr) > i_max_lines
        linesToRemove = array.size(arr) - i_max_lines
        for i = 0 to linesToRemove - 1
            oldLine = array.shift(arr)
            line.delete(oldLine)

// Enhanced Divergence Drawing Function
Drawing(Bull_Line, Bear_Line, Bull_Label, Bear_Label)=>
    // Line style from settings
    lineStyle = getLineStyle()

    // Only process if at least one correlation is valid
    if isCorrelationValid1 or isCorrelationValid2 or isCorrelationValid3
        // Primary Fractal Drawing
        if Last_Bullish_Divergece and Bull_Line
            primaryBullColor = getBullishDivergenceColor(1)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(Low_Per_Bar, low[bar_index - Low_Per_Bar], Low_Last_Bar, low[bar_index - Low_Last_Bar], color=primaryBullColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bullishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(Low_Per_Bar, Low_Per_Hist, Low_Last_Bar, Low_Last_Hist, color=primaryBullColor, width=i_line_width, style=lineStyle)
                array.push(bullishIndicatorLines, indicatorLine)
            
    // Add label if enabled
            if Bull_Label
                label.new(Low_Last_Bar, Low_Last_Hist, "BullDiv\nRegular", color=color.new(primaryBullColor, 50), textcolor=primaryBullColor, style=label.style_label_down, size=size.small)
            
            // Manage lines array
            manageLinesArray(bullishLines)
            manageLinesArray(bullishIndicatorLines)
      
        if Last_Bearish_Divergece and Bear_Line
            primaryBearColor = getBearishDivergenceColor(1)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(High_Per_Bar, high[bar_index - High_Per_Bar], High_Last_Bar, high[bar_index - High_Last_Bar], color=primaryBearColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bearishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(High_Per_Bar, High_Per_Hist, High_Last_Bar, High_Last_Hist, color=primaryBearColor, width=i_line_width, style=lineStyle)
                array.push(bearishIndicatorLines, indicatorLine)
            
            // Add label if enabled
            if Bear_Label
                label.new(High_Last_Bar, High_Last_Hist, "BearDiv\nRegular", color=color.new(primaryBearColor, 50), textcolor=primaryBearColor, style=label.style_label_up, size=size.small)
            
            // Manage lines array
            manageLinesArray(bearishLines)
            manageLinesArray(bearishIndicatorLines)
    
        // Secondary Fractal Drawing
        if Last_Bullish_Divergece2 and Bull_Line
            secondaryBullColor = getBullishDivergenceColor(2)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(Low_Per_Bar2, low[bar_index - Low_Per_Bar2], Low_Last_Bar2, low[bar_index - Low_Last_Bar2], color=secondaryBullColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bullishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(Low_Per_Bar2, Low_Per_Hist2, Low_Last_Bar2, Low_Last_Hist2, color=secondaryBullColor, width=i_line_width, style=lineStyle)
                array.push(bullishIndicatorLines, indicatorLine)
            
            // Add label if enabled
            if Bull_Label
                label.new(Low_Last_Bar2, Low_Last_Hist2, "BullDiv\nSecondary", color=color.new(secondaryBullColor, 50), textcolor=secondaryBullColor, style=label.style_label_down, size=size.small)
            
            // Manage lines array
            manageLinesArray(bullishLines)
            manageLinesArray(bullishIndicatorLines)
      
        if Last_Bearish_Divergece2 and Bear_Line
            secondaryBearColor = getBearishDivergenceColor(2)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(High_Per_Bar2, high[bar_index - High_Per_Bar2], High_Last_Bar2, high[bar_index - High_Last_Bar2], color=secondaryBearColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bearishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(High_Per_Bar2, High_Per_Hist2, High_Last_Bar2, High_Last_Hist2, color=secondaryBearColor, width=i_line_width, style=lineStyle)
                array.push(bearishIndicatorLines, indicatorLine)
            
            // Add label if enabled
            if Bear_Label
                label.new(High_Last_Bar2, High_Last_Hist2, "BearDiv\nSecondary", color=color.new(secondaryBearColor, 50), textcolor=secondaryBearColor, style=label.style_label_up, size=size.small)
            
            // Manage lines array
            manageLinesArray(bearishLines)
            manageLinesArray(bearishIndicatorLines)
    
        // Tertiary Fractal Drawing
        if Last_Bullish_Divergece3 and Bull_Line
            tertiaryBullColor = getBullishDivergenceColor(3)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(Low_Per_Bar3, low[bar_index - Low_Per_Bar3], Low_Last_Bar3, low[bar_index - Low_Last_Bar3], color=tertiaryBullColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bullishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(Low_Per_Bar3, Low_Per_Hist3, Low_Last_Bar3, Low_Last_Hist3, color=tertiaryBullColor, width=i_line_width, style=lineStyle)
                array.push(bullishIndicatorLines, indicatorLine)
            
            // Add label if enabled
            if Bull_Label
                label.new(Low_Last_Bar3, Low_Last_Hist3, "BullDiv\nTertiary", color=color.new(tertiaryBullColor, 50), textcolor=tertiaryBullColor, style=label.style_label_down, size=size.small)
            
            // Manage lines array
            manageLinesArray(bullishLines)
            manageLinesArray(bullishIndicatorLines)
      
        if Last_Bearish_Divergece3 and Bear_Line
            tertiaryBearColor = getBearishDivergenceColor(3)
            
            // Price chart line on main chart
            if i_show_on_main
                priceLine = line.new(High_Per_Bar3, high[bar_index - High_Per_Bar3], High_Last_Bar3, high[bar_index - High_Last_Bar3], color=tertiaryBearColor, width=i_line_width, style=lineStyle, force_overlay=true)
                array.push(bearishLines, priceLine)
            
            // Indicator line on indicator panel
            if i_show_on_indicator
                indicatorLine = line.new(High_Per_Bar3, High_Per_Hist3, High_Last_Bar3, High_Last_Hist3, color=tertiaryBearColor, width=i_line_width, style=lineStyle)
                array.push(bearishIndicatorLines, indicatorLine)
            
            // Add label if enabled
            if Bear_Label
                label.new(High_Last_Bar3, High_Last_Hist3, "BearDiv\nTertiary", color=color.new(tertiaryBearColor, 50), textcolor=tertiaryBearColor, style=label.style_label_up, size=size.small)
            
            // Manage lines array
            manageLinesArray(bearishLines)
            manageLinesArray(bearishIndicatorLines)

// ==========================================
// =========== PLOTTING ====================
// ==========================================

// Visual plots for swing point strength if enabled
var label[] swingLabels = array.new_label()
if i_visualize_strength and barstate.isconfirmed
    // Clean up old labels
    if array.size(swingLabels) > 10
        oldLabel = array.shift(swingLabels)
        label.delete(oldLabel)
    
    // Add new label for swing high
    if isSwingHigh
        strengthText = str.tostring(math.round(swingHighStrength * 10) / 10)
        swingLabel = label.new(bar_index - i_swing_lookback, high[i_swing_lookback], text="SH\n" + strengthText, color=i_mono_mode ? getMonochromeColor(color.new(color.red, 80), i_mono_bear_brightness): color.new(color.red, 80), textcolor= i_mono_mode ? getMonochromeColor(color.red, i_mono_bull_brightness) : color.red, style=label.style_label_down, size=size.small)
        array.push(swingLabels, swingLabel)
    
    // Add new label for swing low
    if isSwingLow
        strengthText = str.tostring(math.round(swingLowStrength * 10) / 10)
        swingLabel = label.new(bar_index - i_swing_lookback, low[i_swing_lookback], text="SL\n" + strengthText, color=i_mono_mode ? getMonochromeColor(color.new(color.green, 80), i_mono_bull_brightness): color.new(color.green, 80), textcolor= i_mono_mode ? getMonochromeColor(color.green, i_mono_bear_brightness) : color.green, style=label.style_label_up, size=size.small)
        array.push(swingLabels, swingLabel)

// Plot swing points if enabled
plotshape(i_show_swing_points and isSwingLow, "Swing Low", shape.triangleup, location.belowbar, i_mono_mode ? getMonochromeColor(i_bullish_swing_color, (i_mono_bull_brightness + 20 > 100 ? 100 : i_mono_bull_brightness + 20)) : i_bullish_swing_color, offset=-i_swing_lookback, force_overlay = true)
plotshape(i_show_swing_points and isSwingHigh, "Swing High", shape.triangledown, location.abovebar, i_mono_mode ? getMonochromeColor(i_bearish_swing_color, (i_mono_bear_brightness - 20 < 0 ? 0 : i_mono_bear_brightness - 20)) : i_bearish_swing_color, offset=-i_swing_lookback, force_overlay = true)

// Adjust opacity for comparison symbol candles
compBullishColor = i_mono_mode ? getMonochromeColor(compSymbolBullishColor, i_mono_bull_brightness) : color.new(compSymbolBullishColor, 100 - i_comp_opacity)
compBearishColor = i_mono_mode ? getMonochromeColor(compSymbolBearishColor, i_mono_bear_brightness) : color.new(compSymbolBearishColor, 100 - i_comp_opacity)
compBullishWickColor = i_mono_mode ? getMonochromeColor(compSymbolBullishWickColor, i_mono_bull_brightness) : color.new(compSymbolBullishWickColor, 100 - i_comp_opacity)
compBearishWickColor = i_mono_mode ? getMonochromeColor(compSymbolBearishWickColor, i_mono_bear_brightness) : color.new(compSymbolBearishWickColor, 100 - i_comp_opacity)

// Symbol-specific colors
compSymbol1BullishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol1BullishColor, i_mono_bull_brightness) : color.new(compSymbol1BullishColor, 100 - i_comp_opacity)) : compBullishColor
compSymbol1BearishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol1BearishColor, i_mono_bear_brightness) : color.new(compSymbol1BearishColor, 100 - i_comp_opacity)) : compBearishColor
compSymbol2BullishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol2BullishColor, i_mono_bull_brightness) : color.new(compSymbol2BullishColor, 100 - i_comp_opacity)) : compBullishColor
compSymbol2BearishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol2BearishColor, i_mono_bear_brightness) : color.new(compSymbol2BearishColor, 100 - i_comp_opacity)) : compBearishColor
compSymbol3BullishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol3BullishColor, i_mono_bull_brightness) : color.new(compSymbol3BullishColor, 100 - i_comp_opacity)) : compBullishColor
compSymbol3BearishColorFinal = i_color_mode == "Unique" ? (i_mono_mode ? getMonochromeColor(compSymbol3BearishColor, i_mono_bear_brightness) : color.new(compSymbol3BearishColor, 100 - i_comp_opacity)) : compBearishColor

// Define plot conditions based on display mode setting
isPrimarySymbol1 = i_enable_sym1  // First enabled symbol is always primary
isPrimarySymbol2 = not i_enable_sym1 and i_enable_sym2  // Symbol 2 is primary only if Symbol 1 is not enabled
isPrimarySymbol3 = not i_enable_sym1 and not i_enable_sym2 and i_enable_sym3  // Symbol 3 is primary only if Symbol 1 and 2 are not enabled

shouldPlotSymbol1 = enableCompSymbolCandles and i_enable_sym1 and (isPrimarySymbol1 or (i_show_additional_symbols and (i_multi_sym_display == "All Enabled" or i_multi_sym_display == "Active Signal" and (markGreen1 or markRed1))))
shouldPlotSymbol2 = enableCompSymbolCandles and i_enable_sym2 and (isPrimarySymbol2 or (i_show_additional_symbols and (i_multi_sym_display == "All Enabled" or i_multi_sym_display == "Active Signal" and (markGreen2 or markRed2))))
shouldPlotSymbol3 = enableCompSymbolCandles and i_enable_sym3 and (isPrimarySymbol3 or (i_show_additional_symbols and (i_multi_sym_display == "All Enabled" or i_multi_sym_display == "Active Signal" and (markGreen3 or markRed3))))

// Plot candlesticks for comparison symbols
plotcandle(shouldPlotSymbol1 ? compSymbol1Open : na, shouldPlotSymbol1 ? compSymbol1High : na, shouldPlotSymbol1 ? compSymbol1Low : na, shouldPlotSymbol1 ? compSymbol1Close : na, title="Symbol 1", color=compSymbol1Close >= compSymbol1Open ? compSymbol1BullishColorFinal : compSymbol1BearishColorFinal, wickcolor=compSymbol1Close >= compSymbol1Open ? compSymbol1BullishColorFinal : compSymbol1BearishColorFinal, bordercolor=compSymbol1BorderColor())

// Adjust offset for Symbol 2 (if needed for clarity)
symbol2Offset = 0  // can be adjusted if needed
plotcandle(shouldPlotSymbol2 ? compSymbol2Open : na, shouldPlotSymbol2 ? compSymbol2High : na, shouldPlotSymbol2 ? compSymbol2Low : na, shouldPlotSymbol2 ? compSymbol2Close : na, title="Symbol 2", color=compSymbol2Close >= compSymbol2Open ? compSymbol2BullishColorFinal : compSymbol2BearishColorFinal, wickcolor=compSymbol2Close >= compSymbol2Open ? compSymbol2BullishColorFinal : compSymbol2BearishColorFinal, bordercolor=compSymbol2BorderColor())

// Adjust offset for Symbol 3 (if needed for clarity)
symbol3Offset = 0  // can be adjusted if needed
plotcandle(shouldPlotSymbol3 ? compSymbol3Open : na, shouldPlotSymbol3 ? compSymbol3High : na, shouldPlotSymbol3 ? compSymbol3Low : na, shouldPlotSymbol3 ? compSymbol3Close : na, title="Symbol 3", color=compSymbol3Close >= compSymbol3Open ? compSymbol3BullishColorFinal : compSymbol3BearishColorFinal, wickcolor=compSymbol3Close >= compSymbol3Open ? compSymbol3BullishColorFinal : compSymbol3BearishColorFinal, bordercolor=compSymbol3BorderColor())

// Plot border colors for main chart
barcolor(mainChartBorderColor(), title="Main Chart Border Highlight")

// Draw all divergence lines
Drawing(Bull_Line, Bear_Line, Bull_Label, Bear_Label)

// Display correlation information for each enabled symbol
var table correlationTable = table.new(position.top_right, 3, 5, bgcolor=color.new(color.black, 90))  // Increased to 5 rows to handle all cases

if barstate.islast and i_show_correlation
    // Clear old table content
    table.clear(correlationTable, 0, 0, 2, 4)  // Clear all 5 rows (0-4)
    
    // Table header
    table.cell(correlationTable, 0, 0, "Symbol", bgcolor=color.new(color.black, 90), text_color=color.white)
    table.cell(correlationTable, 1, 0, "Correlation", bgcolor=color.new(color.black, 90), text_color=color.white)
    table.cell(correlationTable, 2, 0, "Signal", bgcolor=color.new(color.black, 90), text_color=color.white)
    
    // Row counter for inserting correlation data
    rowIndex = 1
    
    // Symbol 1 correlation
    if i_enable_sym1
        correlationColor1 = correlation1 >= i_min_correlation ? color.green : (correlation1 <= -i_min_correlation ? color.red : color.gray)
        signalText1 = markGreen1 ? "Bullish" : (markRed1 ? "Bearish" : "-")
        signalColor1 = markGreen1 ? color.green : (markRed1 ? color.red : color.gray)
        
        table.cell(correlationTable, 0, rowIndex, getShortSymbolName(Sym1), bgcolor=color.new(color.black, 90), text_color=color.white)
        table.cell(correlationTable, 1, rowIndex, str.tostring(math.round(correlation1 * 100) / 100), bgcolor=color.new(color.black, 90), text_color=correlationColor1)
        table.cell(correlationTable, 2, rowIndex, signalText1, bgcolor=color.new(color.black, 90), text_color=signalColor1)
        
        rowIndex += 1
    
    // Symbol 2 correlation
    if i_enable_sym2
        correlationColor2 = correlation2 >= i_min_correlation ? color.green : (correlation2 <= -i_min_correlation ? color.red : color.gray)
        signalText2 = markGreen2 ? "Bullish" : (markRed2 ? "Bearish" : "-")
        signalColor2 = markGreen2 ? color.green : (markRed2 ? color.red : color.gray)
        
        table.cell(correlationTable, 0, rowIndex, getShortSymbolName(Sym2), bgcolor=color.new(color.black, 90), text_color=color.white)
        table.cell(correlationTable, 1, rowIndex, str.tostring(math.round(correlation2 * 100) / 100), bgcolor=color.new(color.black, 90), text_color=correlationColor2)
        table.cell(correlationTable, 2, rowIndex, signalText2, bgcolor=color.new(color.black, 90), text_color=signalColor2)
        
        rowIndex += 1
    
    // Symbol 3 correlation
    if i_enable_sym3
        correlationColor3 = correlation3 >= i_min_correlation ? color.green : (correlation3 <= -i_min_correlation ? color.red : color.gray)
        signalText3 = markGreen3 ? "Bullish" : (markRed3 ? "Bearish" : "-")
        signalColor3 = markGreen3 ? color.green : (markRed3 ? color.red : color.gray)
        
        table.cell(correlationTable, 0, rowIndex, getShortSymbolName(Sym3), bgcolor=color.new(color.black, 90), text_color=color.white)
        table.cell(correlationTable, 1, rowIndex, str.tostring(math.round(correlation3 * 100) / 100), bgcolor=color.new(color.black, 90), text_color=correlationColor3)
        table.cell(correlationTable, 2, rowIndex, signalText3, bgcolor=color.new(color.black, 90), text_color=signalColor3)
        
        rowIndex += 1
    
    // Combined signals row
    if activeSymbolCount > 1
        combinedSignalText = markGreen ? "Bullish" : (markRed ? "Bearish" : "-")
        combinedSignalColor = markGreen ? color.green : (markRed ? color.red : color.gray)
        
        table.cell(correlationTable, 0, rowIndex, "Combined", bgcolor=color.new(color.black, 90), text_color=color.white)
        table.cell(correlationTable, 1, rowIndex, i_signal_mode, bgcolor=color.new(color.black, 90), text_color=color.white)
        table.cell(correlationTable, 2, rowIndex, combinedSignalText, bgcolor=color.new(color.black, 90), text_color=combinedSignalColor)
